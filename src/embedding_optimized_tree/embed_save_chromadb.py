# --- Imports
from sentence_transformers import SentenceTransformer
import torch, os
from chromadb import PersistentClient
from chromadb.config import Settings

# --- Setup
import json
device = "cuda" if torch.cuda.is_available() else "cpu"
print(f"Using device: {device}")
model = SentenceTransformer("all-MiniLM-L6-v2", device=device)

persist_dir = "vector_database"
client = PersistentClient(
    path=persist_dir,
    settings=Settings(anonymized_telemetry=False)
)
coll = client.get_or_create_collection("my_collection")

def extract_text_for_embed(tree_node):
    '''
        - Input: tree_node of the type string, remember that this one is always a string - name
                 for that node, and the pure name for embedding is always the first term of the node
        - Output: return the first term of a given node - just embed that pure name to avoid 
                 any noise generated by the section code / vol number if involved in the name
    '''
    return tree_node.split("_")[0]

def extract_id_from_node(tree_node):
    '''
        Extract the unique ID from a renamed node (the last part after splitting by "_")
    '''
    parts = tree_node.split("_")
    if len(parts) >= 2:
        return parts[-1]  # Return the last part which should be the ID
    return tree_node  # Fallback if no underscore found

def traverse_and_rename(obj, id_counter):
    """
    Recursively traverse the JSON structure and append embedID to every string node.
    id_counter: [int] as mutable counter
    Returns the modified object.
    """
    if isinstance(obj, dict):
        return {k: traverse_and_rename(v, id_counter) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [traverse_and_rename(item, id_counter) for item in obj]
    elif isinstance(obj, str):
        new_name = f"{obj}_{id_counter[0]}"
        id_counter[0] += 1
        return new_name
    else:
        return obj

def embed_json_nodes_and_save(json_path, limit=None, save_json_path=None):
    # Load JSON
    with open(json_path, "r", encoding="utf-8") as f:
        data = json.load(f)
    
    # Collect ALL nodes (including keys and values) to know the total count
    def collect_all_nodes(obj, nodes):
        if isinstance(obj, dict):
            for k, v in obj.items():
                nodes.append(k)  # Add dictionary keys
                collect_all_nodes(v, nodes)
        elif isinstance(obj, list):
            for item in obj:
                collect_all_nodes(item, nodes)
        elif isinstance(obj, str):
            nodes.append(obj)  # Add string values
    
    all_nodes = []
    collect_all_nodes(data, all_nodes)
    print(f"Total nodes found (keys + values): {len(all_nodes)}")
    
    # Apply limit if specified
    if limit is not None:
        print(f"Processing only first {limit} nodes")
        
        def traverse_limit(obj, id_counter, limit_counter):
            if isinstance(obj, dict):
                new_dict = {}
                for k, v in obj.items():
                    # Process the key
                    if limit_counter[0] < limit:
                        new_key = f"{k}_{id_counter[0]}"
                        id_counter[0] += 1
                        limit_counter[0] += 1
                    else:
                        new_key = k
                    
                    # Process the value
                    new_value = traverse_limit(v, id_counter, limit_counter)
                    new_dict[new_key] = new_value
                return new_dict
            elif isinstance(obj, list):
                return [traverse_limit(item, id_counter, limit_counter) for item in obj]
            elif isinstance(obj, str):
                if limit_counter[0] < limit:
                    new_name = f"{obj}_{id_counter[0]}"
                    id_counter[0] += 1
                    limit_counter[0] += 1
                    return new_name
                else:
                    return obj  # Keep original if over limit
            else:
                return obj
        
        id_counter = [0]
        limit_counter = [0]
        new_data = traverse_limit(data, id_counter, limit_counter)
    else:
        # Process all nodes (both keys and values)
        def traverse_and_rename_all(obj, id_counter):
            if isinstance(obj, dict):
                new_dict = {}
                for k, v in obj.items():
                    # Rename the key
                    new_key = f"{k}_{id_counter[0]}"
                    id_counter[0] += 1
                    # Process the value
                    new_value = traverse_and_rename_all(v, id_counter)
                    new_dict[new_key] = new_value
                return new_dict
            elif isinstance(obj, list):
                return [traverse_and_rename_all(item, id_counter) for item in obj]
            elif isinstance(obj, str):
                new_name = f"{obj}_{id_counter[0]}"
                id_counter[0] += 1
                return new_name
            else:
                return obj
        
        id_counter = [0]
        new_data = traverse_and_rename_all(data, id_counter)
    
    # Save new JSON if requested (with proper Unicode handling)
    if save_json_path:
        with open(save_json_path, "w", encoding="utf-8") as f:
            json.dump(new_data, f, indent=2, ensure_ascii=False)  # ensure_ascii=False preserves Unicode
        print(f"Modified JSON saved to {save_json_path}")
    
    # Collect only the nodes that were actually renamed (have IDs)
    renamed_nodes = []
    def collect_renamed_nodes(obj):
        if isinstance(obj, dict):
            for k, v in obj.items():
                # Check if key was renamed
                if "_" in k:
                    parts = k.split("_")
                    try:
                        int(parts[-1])
                        renamed_nodes.append(k)
                    except ValueError:
                        pass
                collect_renamed_nodes(v)
        elif isinstance(obj, list):
            for item in obj:
                collect_renamed_nodes(item)
        elif isinstance(obj, str):
            # Check if string value was renamed
            if "_" in obj:
                parts = obj.split("_")
                try:
                    int(parts[-1])
                    renamed_nodes.append(obj)
                except ValueError:
                    pass
    
    collect_renamed_nodes(new_data)
    print(f"Renamed nodes to embed: {len(renamed_nodes)}")
    
    if not renamed_nodes:
        print("No nodes to embed!")
        return
    
    # Extract texts for embedding and IDs for storage
    embed_texts = [extract_text_for_embed(n) for n in renamed_nodes]
    embed_ids = [extract_id_from_node(n) for n in renamed_nodes]  # Use the ID number, not the text
    
    print(f"Sample embed_texts: {embed_texts[:5]}")
    print(f"Sample embed_ids: {embed_ids[:5]}")
    
    # Embed
    embeddings = model.encode(embed_texts, convert_to_numpy=True, show_progress_bar=True)
    
    # Add to DB
    coll.add(
        embeddings=embeddings.tolist(),
        documents=renamed_nodes,  # Store the full renamed node
        ids=embed_ids  # Use the unique numeric IDs
    )
    print(f"âœ… Embedded {len(embed_ids)} nodes. Data added to DB.")


# --- Example usage: embed first 5 nodes and save modified JSON
json_path = "json_search_tree/optimized_tree.json"
save_json_path = "json_search_tree/optimized_tree_with_ids.json"
embed_json_nodes_and_save(json_path, save_json_path=save_json_path)

# --- List what got written
print("On-disk files:", os.listdir(persist_dir))